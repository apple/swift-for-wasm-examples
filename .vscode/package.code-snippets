//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift open source project
//
// Copyright (c) 2024 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
{
    // Place your swift-for-wasm-example workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
    // Placeholders with the same ids are connected.
    // Example:
    "Saw waveform function": {
        "scope": "swift",
        "prefix": "func saw",
        "body": [
            "func saw(time: Float, frequency: Float) -> Float {",
            "    let phase = time * frequency",
            "",
            "    return 2 * (phase - (0.5 + phase).rounded(.down))",
            "}",
        ],
    },

    "Saw waveform struct": {
        "scope": "swift",
        "prefix": "struct saw",
        "body": [
            "struct Saw {",
            "    var frequency: Float = 440.0",
            "    var amplitude: Float = 1.0",
            "    var currentTime: Float = 0.0",
            "",
            "    mutating func next() -> Float {",
            "        let result = saw(time: currentTime, frequency: frequency)",
            "",
            "        self.currentTime += 1.0 / Float(sampleRate)",
            "        if self.currentTime > 1.0 / frequency {",
            "            self.currentTime = 0",
            "        }",
            "",
            "        return result * amplitude",
            "    }",
            "}",
        ],
    },

    "Waveform signal protocol": {
        "scope": "swift",
        "prefix": "protocol signal",
        "body": [
            "protocol Signal {",
            "    mutating func next() -> Float",
            "}",
        ]
    },

    "HTML entrypoint file": {
        "scope": "html",
        "prefix": "index html",
        "body": [
            "<html>",
            "  <head>",
            "    <meta charset=\"utf-8\">",
            "    <title>Swift Audio Workstation</title>",
            "  </head>",
            "  <body>",
            "    <script type=\"module\" src=\"Sources/JavaScript/index.js\">",
            "    </script>",
            "    <style> ",
            "    #wasm-logger {",
            "      font-family: sans-serif;",
            "    }",
            "    </style>",
            "  </body>",
            "  <h1 id=\"wasm-logger\"></h1>",
            "  <div style=\"display: flex; flex-direction: column; align-items: flex-start; gap: 1rem;\">",
            "  <canvas id=\"tutorial\" width=\"1000\" height=\"210\"></canvas>",
            "  <audio id=\"audio\" type=\"audio.wav\" controls></audio>",
            "  </div>",
            "</html>",
        ]
    },

    "JavaScript entrypoint file": {
        "scope": "javascript",
        "prefix": "index js",
        "body": [
            "function generate() {",
            "  const blob = wavEncoder.finish();",
            "  const audioURL = URL.createObjectURL(blob);",
            "  document.getElementById('audio').setAttribute('src', audioURL);",
            "}",
            "",
            "var setString = function(view, offset, str) {",
            "    var len = str.length;",
            "    for (var i = 0; i < len; ++i)",
            "    view.setUint8(offset + i, str.charCodeAt(i));",
            "};",
            "",
            "var Encoder = function(sampleRate, numChannels) {",
            "    this.sampleRate = sampleRate;",
            "    this.numChannels = numChannels;",
            "    this.numSamples = 0;",
            "    this.dataViews = [];",
            "};",
            "",
            "Encoder.prototype.encode = function(buffer) {",
            "    var len = buffer[0].length,",
            "        nCh = this.numChannels,",
            "        view = new DataView(new ArrayBuffer(len * nCh * 2)),",
            "        offset = 0;",
            "    for (var i = 0; i < len; ++i)",
            "    for (var ch = 0; ch < nCh; ++ch) {",
            "        var x = buffer[ch][i] * 0x7fff;",
            "        view.setInt16(offset, x < 0 ? Math.max(x, -0x8000) : Math.min(x, 0x7fff), true);",
            "        offset += 2;",
            "    }",
            "    this.dataViews.push(view);",
            "    this.numSamples += len;",
            "};",
            "",
            "Encoder.prototype.finish = function() {",
            "    var dataSize = this.numChannels * this.numSamples * 2,",
            "        view = new DataView(new ArrayBuffer(44));",
            "    setString(view, 0, 'RIFF');",
            "    view.setUint32(4, 36 + dataSize, true);",
            "    setString(view, 8, 'WAVE');",
            "    setString(view, 12, 'fmt ');",
            "    view.setUint32(16, 16, true);",
            "    view.setUint16(20, 1, true);",
            "    view.setUint16(22, this.numChannels, true);",
            "    view.setUint32(24, this.sampleRate, true);",
            "    view.setUint32(28, this.sampleRate * 4, true);",
            "    view.setUint16(32, this.numChannels * 2, true);",
            "    view.setUint16(34, 16, true);",
            "    setString(view, 36, 'data');",
            "    view.setUint32(40, dataSize, true);",
            "    this.dataViews.unshift(view);",
            "    var blob = new Blob(this.dataViews, { type: 'audio/wav' });",
            "    this.cleanup();",
            "    return blob;",
            "};",
            "",
            "Encoder.prototype.cancel = Encoder.prototype.cleanup = function() {",
            "    delete this.dataViews;",
            "};",
            "",
            "const canvasElement = document.getElementById('tutorial');",
            "const canvasContext = canvasElement.getContext('2d');",
            "",
            "const decoder = new TextDecoder();",
            "const loggerElement = document.getElementById('wasm-logger');",
            "",
            "function wasmMemoryAsString(address, byteCount) {",
            "  return decoder.decode(instance.exports.memory.buffer.slice(address, address + byteCount));",
            "}",
            "",
            "function wasmMemoryAsFloat32Array(address, byteCount) {",
            "  return new Float32Array(instance.exports.memory.buffer.slice(address, address + byteCount));",
            "}",
            "",
            "const wavEncoder = new Encoder(44100, 1);",
            "",
            "const importsObject = {",
            "  audio: {",
            "    encode: (address, byteCount) => {",
            "      wavEncoder.encode([wasmMemoryAsFloat32Array(address, byteCount)])",
            "      generate();",
            "    },",
            "  },",
            "  canvas: {",
            "    beginPath: () => canvasContext.beginPath(),",
            "    stroke: () => canvasContext.stroke(),",
            "    moveTo: (x, y) => canvasContext.moveTo(x, y),",
            "    lineTo: (x, y) => canvasContext.lineTo(x, y),",
            "  }, ",
            "  console: {",
            "    log: (address, byteCount) => {",
            "      loggerElement.innerHTML = wasmMemoryAsString(address, byteCount);",
            "    },",
            "    logInt: (int) => console.log(int),",
            "    logFloat: (int) => console.log(int),",
            "  }",
            "};",
            "",
            "const { instance } = await WebAssembly.instantiateStreaming(",
            "  fetch('.build/wasm32-unknown-none-wasm/release/swift-audio.wasm'),",
            "  {",
            "    ...importsObject,",
            "  }",
            ");",
            "",
            "instance.exports.hello();",
        ]
    },

    "DOM interop": {
        "scope": "swift",
        "prefix": "dom interop",
        "body": [
            "@_extern(wasm, module: \"console\", name: \"log\")",
            "@_extern(c)",
            "private func consoleLog(address: Int, byteCount: Int)",
            "",
            "@_extern(wasm, module: \"console\", name: \"logInt\")",
            "@_extern(c)",
            "func consoleLogInt(_ int: Int)",
            "",
            "@_extern(wasm, module: \"console\", name: \"logFloat\")",
            "@_extern(c)",
            "func consoleLogFloat(_ float: Float)",
            "",
            "@_extern(wasm, module: \"audio\", name: \"encode\")",
            "@_extern(c)",
            "private func encodeAudio(address: Int, byteCount: Int)",
            "",
            "enum Audio {",
            "    static func encode(_ buffer: some Sequence<Float>) {",
            "        buffer.withContiguousStorageIfAvailable {",
            "            encodeAudio(address: Int(bitPattern: \\$0.baseAddress!), byteCount: MemoryLayout<Float>.stride * \\$0.count)",
            "        }",
            "    }",
            "}",
            "",
            "enum Console {",
            "  static func log(_ string: StaticString) {",
            "     consoleLog(",
            "       address: Int(bitPattern: string.utf8Start), ",
            "       byteCount: string.utf8CodeUnitCount",
            "     )",
            "  }",
            "}",
            "",
        ]
    },
    "Canvas protocol and HTML canvas implementation": {
        "scope": "swift",
        "prefix": "protocol canvas",
        "body": [
            "protocol Canvas {",
            "  static func beginPath()",
            "  static func stroke()",
            "  static func moveTo(x: Int, y: Int)",
            "  static func lineTo(x: Int, y: Int)",
            "}",
            "",
            "struct HTMLCanvas: Canvas {",
            "  @_extern(wasm, module: \"canvas\", name: \"beginPath\")",
            "  @_extern(c)",
            "  static func beginPath()",
            "",
            "  @_extern(wasm, module: \"canvas\", name: \"stroke\")",
            "  @_extern(c)",
            "  static func stroke()",
            "",
            "  @_extern(wasm, module: \"canvas\", name: \"moveTo\")",
            "  @_extern(c)",
            "  static func moveTo(x: Int, y: Int)",
            "",
            "  @_extern(wasm, module: \"canvas\", name: \"lineTo\")",
            "  @_extern(c)",
            "  static func lineTo(x: Int, y: Int)",
            "}",
        ]
    },
    "Audio Buffer struct": {
        "scope": "swift",
        "prefix": "audio buffer",
        "body": [
            "struct AudioBuffer: ~Copyable {",
            "    let storage: UnsafeMutableBufferPointer<Float>",
            "",
            "    init(capacity: Int, source: inout some Signal) {",
            "        self.storage = .allocate(capacity: capacity)",
            "",
            "        for i in self.storage.indices {",
            "            let sample = source.next()",
            "            self.storage[i] = sample",
            "        }",
            "    }",
            "",
            "    deinit {",
            "        self.storage.deallocate()",
            "    }",
            "}",
        ]
    },
    "plotter": {
        "scope": "swift",
        "prefix": "struct plotter",
        "body": [
            "struct Plotter<CanvasType: Canvas> {",
            "    let height: Int",
            "    let width: Int",
            "    let centerY: Int",
            "    let scaleFactor: Float",
            "",
            "    init(width: Int, height: Int, margin: Int) {",
            "        self.width = width",
            "        self.height = height",
            "        self.centerY = (height + margin) / 2",
            "        self.scaleFactor = Float(height) / 4.0",
            "    }",
            "",
            "    func plot(_ audioBuffer: borrowing AudioBuffer) {",
            "        let samplesPerPixel = audioBuffer.storage.count / self.width",
            "",
            "        var sampleCounter = 0",
            "        var averageCounter = 0",
            "        var average: Float = 0",
            "        ",
            "        CanvasType.beginPath()",
            "        CanvasType.moveTo(x: 0, y: centerY)",
            "        for sample in audioBuffer.storage {",
            "            average += sample",
            "",
            "            if sampleCounter < samplesPerPixel {",
            "                sampleCounter += 1",
            "                average += sample",
            "            } else {",
            "                CanvasType.lineTo(x: averageCounter, y: centerY + Int(average * scaleFactor / Float(samplesPerPixel)))",
            "                averageCounter += 1 ",
            "                average = 0",
            "                sampleCounter = 0",
            "            }",
            "        }",
            "",
            "        if average != 0 {",
            "            CanvasType.lineTo(x: averageCounter, y: centerY + Int(average * scaleFactor / Float(sampleCounter)))",
            "        }",
            "",
            "        CanvasType.stroke()",
            "    }",
            "}",
        ]
    },
    "main entrypoint": {
        "scope": "swift",
        "prefix": "func main",
        "body": [
            "@_expose(wasm, \"main\")",
            "func main() {",
            "  var saw = Saw(frequency: 2)",
            "",
            "  let totalLengthInSeconds = 6",
            "  let buffer = AudioBuffer(",
            "    capacity: sampleRate * totalLengthInSeconds,",
            "    source: &saw",
            "  )",
            "  Audio.encode(buffer)",
            "",
            "  Plotter<HTMLCanvas>(",
            "    width: 1000, height: 200, margin: 10",
            "  ).plot(buffer)",
            "}",
        ]
    },

    "Pitch type": {
        "scope": "swift",
        "prefix": "struct pitch",
        "body": [
            "// Equal temperament ratios: https://en.wikipedia.org/wiki/Equal_temperament#Comparison_with_just_intonation",
            "struct Pitch {",
            "    var rawValue: Float",
            "",
            "    func octave(_ octaveShift: Int) -> Pitch {",
            "        Pitch(rawValue: rawValue + Float(octaveShift))",
            "    }",
            "",
            "    static let c     = Pitch(rawValue: 0)",
            "    static let dFlat = Pitch(rawValue: 0.059463)",
            "    static let d     = Pitch(rawValue: 0.122462)",
            "    static let eFlat = Pitch(rawValue: 0.189207)",
            "    static let e     = Pitch(rawValue: 0.259921)",
            "    static let f     = Pitch(rawValue: 0.33484)",
            "    static let gFlat = Pitch(rawValue: 0.414214)",
            "    static let g     = Pitch(rawValue: 0.498307)",
            "    static let aFlat = Pitch(rawValue: 0.587401)",
            "    static let a     = Pitch(rawValue: 0.681793)",
            "    static let bFlat = Pitch(rawValue: 0.781797)",
            "    static let b     = Pitch(rawValue: 0.887749)",
            "}",
        ]
    },

    "Triangle waveform type": {
        "scope": "swift",
        "prefix": "struct triangle",
        "body": [
            "import VultDSP",
            "",
            "struct Triangle: Signal {",
            "    var pitch: Pitch",
            "    var amplitude: Float = 1.0",
            "",
            "    var state = Triangle__ctx_type_0()",
            "",
            "    mutating func next() -> Float {",
            "        Triangle_process(&state, pitch.rawValue / 10.0, 0, 0) * amplitude",
            "    }",
            "}",
        ]
    },

    "Modulator type": {
        "scope": "swift",
        "prefix": "struct modulator",
        "body": [
            "struct Modulator<Source: Signal, Modulation: Signal>: Signal {",
            "    var source: Source",
            "    var modulation: Modulation",
            "",
            "    var sourceUpdate: (inout Source, Float) -> ()",
            "",
            "    mutating func next() -> Float {",
            "        sourceUpdate(&self.source, modulation.next())",
            "        return self.source.next()",
            "    }",
            "}",
        ]
    },

    "Envelope generator": {
        "scope": "swift",
        "prefix": "struct envelope",
        "body": [
            "import VultDSP",
            "",
            "struct AttackHoldRelease: Signal {",
            "    var state = Ahr__ctx_type_0()",
            "",
            "    var attack: Float = 0.0",
            "    var hold: Float = 0.5",
            "    var release: Float = 0.5",
            "",
            "    var isNoteOn = false",
            "",
            "    mutating func next() -> Float {",
            "        Ahr_do(&state, isNoteOn ? 1 : 0, attack, hold, release)",
            "        return Ahr_do_ret_0(&state)",
            "    }",
            "}",
        ]
    },

    "Sequencer declarations": {
        "scope": "swift",
        "prefix": "sequencer",
        "body": [
            "enum SequencerStep {",
            "    case noteOff",
            "    case noteOn(Pitch)",
            "}",
            "",
            "protocol SequencedInstrument: Signal {",
            "    var currentStep: SequencerStep { get set }",
            "}",
            "",
            "struct Sequencer<Instrument: SequencedInstrument>: Signal {",
            "    var instrument: Instrument",
            "",
            "    let sequence: [SequencerStep]",
            "",
            "    let stepLengthInSeconds: Float",
            "",
            "    var currentSample = 0",
            "",
            "    mutating func next() -> Float {",
            "        let stepLengthInSamples = Int(stepLengthInSeconds * Float(sampleRate))",
            "        var currentStepIndex = currentSample / stepLengthInSamples",
            "",
            "        if currentStepIndex >= sequence.count {",
            "            currentSample = currentSample % stepLengthInSamples",
            "            currentStepIndex = 0",
            "        }",
            "",
            "        self.instrument.currentStep = sequence[currentStepIndex]",
            "        currentSample += 1",
            "",
            "        return self.instrument.next()",
            "    }",
            "}",
        ]
    },

    "Bass instrument": {
        "scope": "swift",
        "prefix": "bass",
        "body": [
            "struct Bass: SequencedInstrument {",
            "    var currentStep: SequencerStep = .noteOff {",
            "        didSet {",
            "            switch self.currentStep {",
            "            case .noteOff:",
            "                core.modulation.isNoteOn = false",
            "            case .noteOn(let pitch):",
            "                core.source.pitch = pitch",
            "                core.modulation.isNoteOn = true",
            "            }",
            "        }",
            "    }",
            "",
            "    var core = Modulator(",
            "        source: Triangle(pitch: .g), ",
            "        modulation: AttackHoldRelease(),",
            "        sourceUpdate: { signal, amplitude in",
            "            signal.amplitude = amplitude ",
            "        }",
            "    )",
            "",
            "    mutating func next() -> Float {",
            "        core.next()",
            "    }",
            "}",
        ]
    },

    "Drums": {
        "scope": "swift",
        "prefix": "drums",
        "body": [
            "import VultDSP",
            "",
            "struct Noise: Signal {",
            "    var state = Noise__ctx_type_1()",
            "    var amplitude: Float = 1.0",
            "",
            "    mutating func next() -> Float {",
            "        Noise_process(&state, 1.0) * amplitude",
            "    }",
            "}",
            "",
            "struct HiHat: SequencedInstrument {",
            "    var currentStep: SequencerStep = .noteOff {",
            "        didSet {",
            "            switch self.currentStep {",
            "            case .noteOff:",
            "                core.modulation.isNoteOn = false",
            "            case .noteOn(_):",
            "                core.modulation.isNoteOn = true",
            "            }",
            "        }",
            "    }",
            "",
            "    var core = Modulator(",
            "        source: Noise(),",
            "        modulation: AttackHoldRelease(attack: 0.01, hold: 0.01, release: 0.2),",
            "        sourceUpdate: { triangle, amplitude in",
            "            triangle.amplitude = amplitude ",
            "        }",
            "    )",
            "",
            "    mutating func next() -> Float {",
            "        core.next()",
            "    }",
            "}",
            "",
            "struct Kick: SequencedInstrument {",
            "    var state = Kick__ctx_type_1()",
            "",
            "    var currentStep: SequencerStep = .noteOn(.e) {",
            "        didSet {",
            "            switch self.currentStep {",
            "                case .noteOn(let pitch):",
            "                    Kick_controlChange(&state, 31, Int32(pitch.rawValue * 10), 0)",
            "                case .noteOff:",
            "                    break",
            "            }",
            "        }",
            "    }",
            "    ",
            "    mutating func next() -> Float {",
            "        switch self.currentStep {",
            "            case .noteOff:",
            "                Kick_process(&state, 0)",
            "            case .noteOn:",
            "                Kick_process(&state, 1)",
            "        }",
            "    }",
            "}",
        ]
    },

    "Mixed sequence": {
        "scope": "swift",
        "prefix": "struct mixer",
        "body": [
            "struct Mixer<Source1: Signal, Source2: Signal, Source3: Signal>: Signal {",
            "    var source1: Source1",
            "    var volume1: Float = 1.0",
            "",
            "    var source2: Source2",
            "    var volume2: Float = 1.0",
            "",
            "    var source3: Source3",
            "    var volume3: Float = 1.0",
            "",
            "    mutating func next() -> Float {",
            "        self.source1.next() * volume1 +",
            "            self.source2.next() * volume2 +",
            "            self.source3.next() * volume3",
            "    }",
            "}",
        ]
    },

    "Mixed main": {
        "scope": "swift",
        "prefix": "mixed main",
        "body": [
            "@_expose(wasm, \"main\")",
            "func main() {",
            "  let sequencedKick = Sequencer(",
            "    instrument: Kick(), ",
            "    sequence: [.noteOff, .noteOn(.c.octave(1)), .noteOff, .noteOn(.c.octave(1))],",
            "    stepLengthInSeconds: 0.25",
            "  )",
            "",
            "  let sequencedHiHat = Sequencer(",
            "    instrument: HiHat(), ",
            "    sequence: [",
            "      .noteOff, .noteOff, .noteOff, .noteOff, ",
            "      .noteOff, .noteOff, .noteOff, .noteOff, ",
            "      .noteOn(.c.octave(1)), .noteOff, .noteOn(.c.octave(1)), .noteOff,",
            "      .noteOff, .noteOff, .noteOff, .noteOff, ",
            "    ],",
            "    stepLengthInSeconds: 0.125",
            "  )",
            "",
            "  let sequencedBass = Sequencer(",
            "    instrument: Bass(), ",
            "    sequence: [",
            "      .noteOn(.c.octave(1)), .noteOff, .noteOn(.d.octave(1)), .noteOff, .noteOn(.e.octave(1)),",
            "      .noteOff, .noteOn(.f.octave(1)), .noteOff, .noteOn(.g.octave(1)), .noteOff, .noteOn(.a.octave(1)),",
            "    ],",
            "    stepLengthInSeconds: 0.25",
            "  )",
            "",
            "  var mixer = Mixer(",
            "    source1: sequencedHiHat,",
            "    volume1: 0.05,",
            "    source2: sequencedKick,",
            "    volume2: 0.6,",
            "    source3: sequencedBass,",
            "    volume3: 0.1",
            "  )",
            "",
            "  let totalLengthInSeconds = 6",
            "  let buffer = AudioBuffer(",
            "    capacity: sampleRate * totalLengthInSeconds",
            "    source: &mixer",
            "  )",
            "  buffer.fill(source: &mixer)",
            "  Audio.encode(buffer)",
            "",
            "  Plotter<HTMLCanvas>(",
            "    width: 1000, height: 200, margin: 10",
            "  ).plot(buffer)",
            "}",
        ]
    }
}